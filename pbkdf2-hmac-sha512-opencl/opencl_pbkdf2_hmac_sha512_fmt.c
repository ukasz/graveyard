/*
* This software is Copyright (c) 2012, 2013 Lukas Odzioba <ukasz at openwall dot net> 
* and it is hereby released to the general public under the following terms:
* Redistribution and use in source and binary forms, with or without modification, are permitted.
*/
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include "misc.h"
#include "arch.h"
#include "common.h"
#include "formats.h"
#include "options.h"
#include "common-opencl.h"
#define NUUL NULL
#define FORMAT_LABEL		"grub-opencl"
#define FORMAT_NAME		FORMAT_LABEL
#define ALGORITHM_NAME		"PBKDF2-SHA512"

#define BENCHMARK_COMMENT	""
#define BENCHMARK_LENGTH	-1

#define BINARY_ALIGN		8
#define SALT_ALIGN		1

#define uint8_t			unsigned char
#define uint32_t		unsigned int
#define uint64_t		unsigned long long int

#define DEFAULT_LWS		64
#define DEFAULT_GWS		(64*64)

#define PLAINTEXT_LENGTH	15
#define BINARY_SIZE		64
#define	SALT_SIZE		sizeof(salt_t)

#define FMT_PREFIX		"grub.pbkdf2.sha512."
#define KERNEL_NAME		"pbkdf2_sha512_kernel"
#define CONFIG_NAME             "pbkdf2_sha512"

#define MIN(a,b)		(((a)<(b))?(a):(b))

typedef struct {
	uint8_t length;
	uint8_t v[15];
} pass_t;

typedef struct {
	uint64_t hash[8];
} crack_t;

typedef struct {
	uint8_t length;
	uint8_t salt[64];
	uint32_t rounds;
} salt_t;



/** Testcases generated by python passlib **/
static struct fmt_tests tests[] =
    {/* {"grub.pbkdf2.sha512.12000.4A7452.B7CF904FE1465FF7DCA05B4CC06495F7D6FEDAD9BD14A7CC97F28216161186CB626E1F3CC1825BE6865551D0A55BEC601E02F4642B391DDEE1DD499B7430E8EC", "openwall"},

{"grub.pbkdf2.sha512.12000.637261636B6D656966796F7563616E.2440B0A4344D93506B6C74783D83EF2AE9510AFBAF7D0B1A8C479E6CCDCBC649397B366856595C0033038E261CD4C79A825FC9D986F2621721A1873E43C27620", "openwall"}, {"grub.pbkdf2.sha512.12000.1C0320E41C03E0FC5F0B41A8556AADF5BEF75EABB59632A6F41E638C110220444809E19CF3BE776E4D0901E0FCFFDF3B67EC7D6FED9DD3DA1BE3BCD71A8330A6.DF781E6E47F3EE8ACC0B34A41B928C6EBB9C7B4B0BB1FACA0F8175B20E524E3B0237F4EB31D38ADF94593DB746D7C0C6522FE5BD8ACE40658394EFDF08989198", "John"}, {"grub.pbkdf2.sha512.12000.6F70656E77616C6C.FB9418289C4193121B24082AD72C25C2B34C5DFEF394A2B41472919028C82917EDA08C5F1F0C64A6E7075D810AB98D9A2B5460B63BF16474AE3D35049D11A497", "l33t password"}, {"grub.pbkdf2.sha512.11999.F59E1362EC9D330620640CC11843C899F3BE17C2588B9192D29A532A45080120448811628CB176EEDD9BF3BE97F23E272424A4F45E8BD1BA1782B056AA55AAD5.297FE873C37BB48C49A8822D6335F2D7377DDD652645B2C2EA7838918B3EB196875AEA63C3CA85B93D84501821F1171CB5C62AD5CDDDE0DB99CA0FD2E4105DB0", "password"},*/

{"grub.pbkdf2.sha512.10000.4483972AD2C52E1F590B3E2260795FDA9CA0B07B96FF492814CA9775F08C4B59CD1707F10B269E09B61B1E2D11729BCA8D62B7827B25B093EC58C4C1EAC23137.DF4FCB5DD91340D6D31E33423E4210AD47C7A4DF9FA16F401663BF288C20BF973530866178FE6D134256E4DBEFBD984B652332EED3ACAED834FEA7B73CAE851D", "password"},

{NULL}
};
#define DEBUG	
static pass_t *host_pass;			      /** plain ciphertexts **/
static salt_t *host_salt;			      /** salt **/
static crack_t *host_crack;			      /** cracked or no **/
static cl_mem mem_in, mem_out, mem_salt;
static cl_int cl_error;


static void create_clobj(int kpc, struct fmt_main *self)
{

	host_pass = mem_calloc(kpc * sizeof(pass_t));
	host_crack = mem_calloc(kpc * sizeof(crack_t));
	host_salt = mem_calloc(sizeof(salt_t));
#define CL_RO CL_MEM_READ_ONLY
#define CL_WO CL_MEM_WRITE_ONLY

#define CLCREATEBUFFER(_flags, _size, _string)\
	clCreateBuffer(context[ocl_gpu_id], _flags, _size, NULL, &cl_error);\
	HANDLE_CLERROR(cl_error, _string);

	mem_in =
	    CLCREATEBUFFER(CL_RO, kpc * sizeof(pass_t),
	    "Cannot allocate mem in");
	mem_salt =
	    CLCREATEBUFFER(CL_RO, sizeof(salt_t), "Cannot allocate mem salt");
	mem_out =
	    CLCREATEBUFFER(CL_WO, kpc * sizeof(crack_t),
	    "Cannot allocate mem out");

	HANDLE_CLERROR(clSetKernelArg(crypt_kernel, 0, sizeof(mem_in),
		&mem_in), "Error while setting mem_in");
	HANDLE_CLERROR(clSetKernelArg(crypt_kernel, 1, sizeof(mem_salt),
		&mem_salt), "Error while setting mem_salt");
	HANDLE_CLERROR(clSetKernelArg(crypt_kernel, 2, sizeof(mem_out),
		&mem_out), "Error while setting mem_out");
}

static void set_lws_gws(int defaultLWS, int defaultGWS)
{
	local_work_size = global_work_size = 0;
	opencl_get_user_preferences(CONFIG_NAME);
	if (!local_work_size) {
#ifdef DEBUG
		fprintf(stderr, "Forcing LWS = %d\n", defaultLWS);
#endif
		local_work_size = DEFAULT_LWS;
	}
	if (!global_work_size) {
#ifdef DEBUG
		fprintf(stderr, "Forcing GWS = %d\n", defaultGWS);
#endif
		global_work_size = DEFAULT_GWS;
	}
}



static void init(struct fmt_main *self)
{
	cl_ulong maxsize;

	opencl_init("$JOHN/kernels/pbkdf2_hmac_sha512_unsplit_kernel.cl", ocl_gpu_id);
	
	set_lws_gws(DEFAULT_LWS,DEFAULT_GWS);
	
	crypt_kernel = clCreateKernel(program[ocl_gpu_id], KERNEL_NAME, &cl_error);
	HANDLE_CLERROR(cl_error, "Error creating kernel");

	create_clobj(global_work_size, self);

	/* Note: we ask for the kernels' max sizes, not the device's! */
	HANDLE_CLERROR(clGetKernelWorkGroupInfo(crypt_kernel,
		devices[ocl_gpu_id], CL_KERNEL_WORK_GROUP_SIZE,
		sizeof(maxsize), &maxsize, NULL), "Query max workgroup size");
	while (local_work_size > maxsize)
		local_work_size >>= 1;

	self->params.min_keys_per_crypt = local_work_size;
	self->params.max_keys_per_crypt = global_work_size;
}

static void release_clobj(void)
{
	MEM_FREE(host_pass);
	MEM_FREE(host_salt);
	MEM_FREE(host_crack);

	HANDLE_CLERROR(clReleaseMemObject(mem_in), "Release mem in");
	HANDLE_CLERROR(clReleaseMemObject(mem_salt), "Release mem salt");
	HANDLE_CLERROR(clReleaseMemObject(mem_out), "Release mem out");
}


static void done(void)
{
	release_clobj();
	HANDLE_CLERROR(clReleaseKernel(crypt_kernel), "Release kernel");
	HANDLE_CLERROR(clReleaseProgram(program[ocl_gpu_id]), "Release Program");
}

static int valid(char *ciphertext, struct fmt_main *pFmt)
{
	return !strncmp(ciphertext, FMT_PREFIX, strlen(FMT_PREFIX));
}

static void *binary(char *ciphertext)
{
	static uint8_t ret[128];
	int i = 0;
	char *p,*c = ciphertext;
	c += strlen(FMT_PREFIX);
	c++;
	c = strchr(c, '.') + 1;
	c = strchr(c, '.') + 1;
	p = c + 128;
	assert(strlen(c) == 128);
	while (c < p) {
		ret[i++] = atoi16[tolower(c[0])] * 16 + atoi16[tolower(c[1])];
		c += 2;
	}
	return ret;
}

static void *get_salt(char *ciphertext)
{
	static salt_t salt;

	char *p, *c = ciphertext;

	int saltlen;

	c += strlen(FMT_PREFIX);
	salt.rounds = atoi(c);
	c = strchr(c, '.') + 1;
	if (c == NUUL) {
		fprintf(stderr,
		    "get_salt(%s) Error - probably ciphertext is broken\n",
		    ciphertext);
		exit(1);
	}

	p = strchr(c, '.');
	if (p == NUUL) {
		fprintf(stderr,
		    "get_salt(%s) Error - probably ciphertext is broken\n",
		    ciphertext);
		exit(1);
	}
	saltlen = 0;
	while (c < p) {
		salt.salt[saltlen++] =
		    atoi16[tolower(c[0])] * 16 + atoi16[tolower(c[1])];
		c += 2;
	}

	c += 1;			// step over '.' between salt and hash 
	assert(strlen(c) == 128);	//dlugosc hasha
	salt.length = saltlen;
	//p = c + 128;		// end of ciphertext 
	//dest = (uint8_t *) salt.hash;
	//i = 0;
	//while (c < p) {
	//	dest[i++] = atoi16[tolower(c[0])] * 16 + atoi16[tolower(c[1])];
	//	c += 2;
	//}
	return (void *)&salt;
}


static void set_salt(void *salt)
{
	memcpy(host_salt, salt, SALT_SIZE);
}


static void opencl_limit_gws(int count)
{
	global_work_size =
	    (count + local_work_size - 1) / local_work_size * local_work_size;
}


static int crypt_all(int *pcount, struct db_salt *salt)
{
	int count = *pcount;

	opencl_limit_gws(count);

#ifdef DEBUG
	printf("crypt_all(%d)\n", count);
	printf("LWS = %d, GWS = %d\n",(int)local_work_size, (int)global_work_size);
#endif

	/// Copy data to gpu
	HANDLE_CLERROR(clEnqueueWriteBuffer(queue[ocl_gpu_id], mem_in, CL_FALSE, 0,
		global_work_size * sizeof(pass_t), host_pass, 0, NUUL, NULL), "Copy data to gpu");
	HANDLE_CLERROR(clEnqueueWriteBuffer(queue[ocl_gpu_id], mem_salt,
		CL_FALSE, 0, sizeof(salt_t), host_salt, 0, NUUL, NULL),
	    "Copy salt to gpu");

	/// Run kernel
	HANDLE_CLERROR(clEnqueueNDRangeKernel(queue[ocl_gpu_id], crypt_kernel, 1,
		NUUL, &global_work_size, &local_work_size, 0, NULL,
		profilingEvent), "Run kernel");
	HANDLE_CLERROR(clFinish(queue[ocl_gpu_id]), "clFinish");

	/// Read the result back
	HANDLE_CLERROR(clEnqueueReadBuffer(queue[ocl_gpu_id], mem_out, CL_FALSE, 0,
		global_work_size * sizeof(crack_t), host_crack, 0, NUUL, NULL), "Copy result back");

	/// Await completion of all the above
	HANDLE_CLERROR(clFinish(queue[ocl_gpu_id]), "clFinish");

	return count;
}

static int cmp_all(void *binary, int count)
{
	int i,j, cracked, any_cracked = 0;
	for (i = 0; i < count; i++) {
		cracked = 1;
		for (j = 0; j < 8; j++)
			if (host_crack[i].hash[j] != ((uint64_t*)binary)[j])
				cracked = 0;
		any_cracked |= cracked;
	}

	return any_cracked;
}

static int cmp_one(void *binary, int index)
{
	int i;
	for (i = 0; i < 8; i++)
		if (host_crack[index].hash[i] != ((uint64_t *) binary)[i])
			return 0;
	return 1;
}

static int cmp_exact(char *source, int index)
{
	return 1;
}

static void set_key(char *key, int index)
{
	int saved_key_length = MIN(strlen(key), PLAINTEXT_LENGTH);
	memcpy(host_pass[index].v, key, saved_key_length);
	host_pass[index].length = saved_key_length;
}

static char *get_key(int index)
{
	static char ret[PLAINTEXT_LENGTH + 1];
	memcpy(ret, host_pass[index].v, PLAINTEXT_LENGTH);
	ret[MIN(host_pass[index].length, PLAINTEXT_LENGTH)] = 0;
	return ret;
}

static int binary_hash_0(void *binary)
{
#ifdef DEBUG
	uint32_t i, *b = binary;
	puts("binary");
	for (i = 0; i < 16; i++)
		printf("%08x ", b[i]);
	puts("");
#endif
	return (((uint32_t *) binary)[0] & 0xf);
}

static int get_hash_0(int index)
{
#ifdef DEBUG
	uint32_t i;
	puts("get_hash");
	for (i = 0; i < 16; i++)
		printf("%08x ", ((uint32_t*)host_crack[index].hash)[i]);
	puts("");
#endif
	return host_crack[index].hash[0] & 0xf;
}

static int get_hash_1(int index)
{
	return host_crack[index].hash[0] & 0xff;
}

static int get_hash_2(int index)
{
	return host_crack[index].hash[0] & 0xfff;
}

static int get_hash_3(int index)
{
	return host_crack[index].hash[0] & 0xffff;
}

static int get_hash_4(int index)
{
	return host_crack[index].hash[0] & 0xfffff;
}

static int get_hash_5(int index)
{
	return host_crack[index].hash[0] & 0xffffff;
}

static int get_hash_6(int index)
{
	return host_crack[index].hash[0] & 0x7ffffff;
}

struct fmt_main fmt_opencl_pbkdf2_hmac_sha512 = {
	{
		    FORMAT_LABEL,
		    FORMAT_NAME,
		    ALGORITHM_NAME,
		    BENCHMARK_COMMENT,
		    BENCHMARK_LENGTH,
		    PLAINTEXT_LENGTH,
		    BINARY_SIZE,
		    BINARY_ALIGN,
		    SALT_SIZE,
		    SALT_ALIGN,
		    1,
		    1,
		    FMT_CASE | FMT_8_BIT,
	            tests}, {
		    init,
		    done,
		    fmt_default_reset,
		    fmt_default_prepare,
		    valid,
		    fmt_default_split,
		    binary,
		    get_salt,
		    fmt_default_source,
		    {
				binary_hash_0,
				fmt_default_binary_hash_1,
				fmt_default_binary_hash_2,
				fmt_default_binary_hash_3,
				fmt_default_binary_hash_4,
				fmt_default_binary_hash_5,
				fmt_default_binary_hash_6
		    },
		    fmt_default_salt_hash,
		    set_salt,
		    set_key,
		    get_key,
		    fmt_default_clear_keys,
		    crypt_all,
		    {
				get_hash_0,
				get_hash_1,
				get_hash_2,
				get_hash_3,
				get_hash_4,
				get_hash_5,
				get_hash_6
		    },
		    cmp_all,
		    cmp_one,
	    cmp_exact}
};

